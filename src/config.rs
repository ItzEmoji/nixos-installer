use serde::{Deserialize, Serialize};
use std::path::Path;

use crate::theme::ThemeName;

/// Default path for the system-wide installer configuration.
pub const DEFAULT_CONFIG_PATH: &str = "/etc/nixos-installer/config.toml";

/// Installer-level configuration (lives at /etc/nixos-installer/config.toml or a custom path).
/// This is the config the user edits via `--init` and loads via `--config`.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(default)]
pub struct InstallerConfig {
    /// The git repository URL to clone (overrides the built-in default).
    pub repo_url: Option<String>,

    /// Color theme name (e.g. "catppuccin-mocha", "nord", "dracula", "tokyo-night", "gruvbox").
    pub theme: Option<ThemeName>,

    /// Home Manager base modules that are always included (never shown in selection).
    /// These are referenced as `self.homeManagerModules.<name>` in the generated nix.
    pub hm_base_modules: Vec<String>,
}

impl Default for InstallerConfig {
    fn default() -> Self {
        Self {
            repo_url: None,
            theme: None,
            hm_base_modules: Vec::new(),
        }
    }
}

/// Load the installer config from a given path.
/// Returns the default config if the file doesn't exist or can't be parsed.
pub fn load_config(path: &Path) -> InstallerConfig {
    match std::fs::read_to_string(path) {
        Ok(content) => match toml::from_str::<InstallerConfig>(&content) {
            Ok(cfg) => cfg,
            Err(e) => {
                eprintln!("Warning: Failed to parse {}: {}", path.display(), e);
                InstallerConfig::default()
            }
        },
        Err(_) => InstallerConfig::default(),
    }
}

/// Load a repo-level config.toml from the repository root.
/// This merges only the repo-level fields (hm_base_modules) into an existing config.
pub fn load_repo_config(base_path: &Path, existing: &InstallerConfig) -> InstallerConfig {
    let config_path = base_path.join("config.toml");
    match std::fs::read_to_string(&config_path) {
        Ok(content) => match toml::from_str::<InstallerConfig>(&content) {
            Ok(repo_cfg) => {
                let mut merged = existing.clone();
                // Repo-level hm_base_modules overrides if non-empty
                if !repo_cfg.hm_base_modules.is_empty() {
                    merged.hm_base_modules = repo_cfg.hm_base_modules;
                }
                // Repo-level repo_url / theme can also override if set
                if repo_cfg.repo_url.is_some() {
                    merged.repo_url = repo_cfg.repo_url;
                }
                if repo_cfg.theme.is_some() {
                    merged.theme = repo_cfg.theme;
                }
                merged
            }
            Err(e) => {
                eprintln!("Warning: Failed to parse repo config.toml: {}", e);
                existing.clone()
            }
        },
        Err(_) => existing.clone(),
    }
}

/// Generate the default config.toml content for `--init`.
pub fn generate_default_config() -> String {
    let available = ThemeName::all_names().join(", ");
    format!(
        r#"# NixOS Installer Configuration
# Generated by nixos-installer --init

# Git repository URL for the NixOS dotfiles/flake to install from.
# If not set, the built-in default is used.
# repo_url = "https://github.com/ItzEmoji/nixos-dotfiles.git"

# Color theme for the installer TUI.
# Available themes: {available}
# theme = "catppuccin-mocha"

# Home Manager base modules that are always included for every user
# (never shown in the selection screen).
# hm_base_modules = ["home"]
"#,
        available = available
    )
}

/// Write the default config to /etc/nixos-installer/config.toml (or a custom path).
/// Creates the directory if it doesn't exist.
pub fn init_config(path: &Path) -> Result<(), String> {
    if let Some(parent) = path.parent() {
        std::fs::create_dir_all(parent)
            .map_err(|e| format!("Failed to create directory {}: {}", parent.display(), e))?;
    }

    let content = generate_default_config();
    std::fs::write(path, &content)
        .map_err(|e| format!("Failed to write {}: {}", path.display(), e))?;

    Ok(())
}
